/[\n]/      { lex.l += 1 }
/[ \t]/     { /* Skip blanks and tabs. */ }


/[0-9]+/    { lval.Value = yylex.Text(); lval.Kind = INT_LITER; return INT_LITER }
/(false|true)/ { lval.Value = yylex.Text(); lval.Kind = BOOL_LITER; return BOOL_LITER }
/"([^"\\]| |(\\(0|b|t|n|f|r|'|"|\\)))*"/ { lval.Value = ProcessStr(yylex.Text()); lval.Kind = STR_LITER; return STR_LITER }
/'([^"\\]| |(\\(0|b|t|n|f|r|'|"|\\)))'/ { lval.Value = ProcessStr(yylex.Text()); lval.Kind = CHAR_LITER; return CHAR_LITER }
/null/      { return PAIR_LITER }

/begin/     { return BEGIN }
/end/       { return END }

/skip/      { return SKIP }
/=/         { return '=' }
/read/      { return READ }
/free/      { return FREE }
/return/    { return RETURN }
/exit/      { return EXIT }
/print/     { return PRINT }
/println/   { return PRINTLN }
/newpair/   { return NEWPAIR }
/call/      { return CALL }

/int/       { lval.Kind = INT; return INT }
/bool/      { lval.Kind = BOOL; return BOOL }
/char/      { lval.Kind = CHAR; return CHAR }
/string/    { lval.Kind = STRING; return STRING }
/pair/      { lval.Kind = PAIR; return PAIR }
/is/        { return FUNC_IS }

/if/        { return IF }
/then/      { return THEN }
/else/      { return ELSE }
/fi/        { return FI }

/while/     { return WHILE }
/do/        { return DO }
/done/      { return DONE }

/;/         { return ';' }
/,/         { return ',' }

/!/         { return '!' }
/len/       { return LEN }
/ord/       { return ORD }
/chr/       { return CHR }
/fst/       { return FST }
/snd/       { return SND }

/\*/        { return '*' }
/\//        { return '/' }
/%/         { return '%' }
/\+/        { return '+' }
/\-/        { return '-' }
/</         { return '<' }
/>/         { return '>' }
/<=/        { return LE }
/>=/        { return GE }
/==/        { return EQ }
/!=/        { return NE }
/&&/        { return AND }
/\|\|/      { return OR }

/[_a-zA-Z][_a-zA-Z0-9]*/ { lval.Value = yylex.Text(); return IDENT }

/\[/        { return '[' }
/\]/        { return ']' }
/\(/        { return '(' }
/\)/        { return ')' }

/#[^\n]*\n/ { lex.l += 1 /* Comments should be ignored */ }

/./         { lex.Error("Invalid Char") }

//
package main

import (
	"os"
	"fmt"
	"flag"
	"strconv"
)

const SYNTAX_ERROR = 100

var lex *Lexer
var exitFlag int = 0

func ProcessStr(s string) string {
	s = s[1:len(s) - 1]

	// Replace escaped characters with their unicode equivalent
	output := ""
	for i := 0; i < len(s); i++ {
		if s[i] == '\\' {
			i++
			switch s[i] {
				case '0': output += "\000"
				case 'b': output += "\b"
				case 't': output += "\t"
				case 'n': output += "\n"
				case 'f': output += "\f"
				case 'r': output += "\r"
				case '\047': output += "\047"
				case '\042': output += "\042"
				case '\\': output += "\\"
				default: panic("Encountered an unknown escape sequence, this should never happen")
			}
		} else {
			output += string(s[i])
		}
	}
	return output
}

func (*Lexer) Error(s string) {
	unexpectedToken := "<EOF>"
	if len(lex.stack) > 0 {
		unexpectedToken = strconv.Quote(lex.Text())
	}
	fmt.Printf("Line %d: %s -- unexpected %s\n", lex.l, s, unexpectedToken)
	exitFlag = SYNTAX_ERROR
}

func main() {
	enableDebug := flag.Bool("d", false, "Enable debug mode")
	flag.Parse()

	if *enableDebug {
		yyDebug = 20
	}

	// Parse the tree
	// We tend to think of the first line as line 1, not line 0
	lex = NewLexerWithInit(os.Stdin, func(l *Lexer){l.l = 1})
	yyParse(lex)
	if exitFlag != 0 {
		os.Exit(SYNTAX_ERROR)
	}
	
	fmt.Println(top.Stmt.Repr())
}
