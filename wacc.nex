/[ \t]/  { /* Skip blanks and tabs. */ }
/[+\-]?[0-9]+/ { lval.Value = yylex.Text(); lval.Kind = INT_LITER; return INT_LITER }
/(false|true)/ { lval.Value = yylex.Text(); lval.Kind = BOOL_LITER; return BOOL_LITER }
/"([a-zA-Z0-9]| |(\\(0|b|t|n|f|r|'|"|\\)))*"/ { lval.Value = processStr(yylex.Text()); lval.Kind = STR_LITER; return STR_LITER }
/'([a-zA-Z0-9]| |(\\(0|b|t|n|f|r|'|"|\\)))'/ { lval.Value = processStr(yylex.Text()); lval.Kind = CHAR_LITER; return CHAR_LITER }
/begin/ { return BEGIN }
/end/ { return END }
/exit/ { return EXIT }
/skip/ { return SKIP }
/null/ { return PAIR_LITER }
/int|bool|char|string/ { return BASE_TYPE }
/pair/ { return PAIR }
/is/ { return FUNC_IS }
/if/ { return IF }
/then/ { return THEN }
/else/ { return ELSE }
/fi/ { return FI }
/;/ { return STATEMENT_SEPARATOR }
/,/ { return COMMA }
/!|-|len|ord|chr/ { return UNARY_OPER }
/\*|\/|%|\+|-|[><]=?|[=!]=|&&|\|\|/ { return BINARY_OPER }
/[_a-zA-Z][_a-zA-Z0-9]*/ { return IDENT }
/\[/ { return SQUARE_BRACKET_OPEN }
/\]/ { return SQUARE_BRACKET_CLOSE }
/\(/ { return ROUND_BRACKET_OPEN }
/\)/ { return ROUND_BRACKET_CLOSE }
/./ { /* wtf is this? */ }
//
package main

import (
	"os"
	"fmt"
)

func processStr(s string) string {
	s = s[1:len(s) - 1]

	// Replace escaped characters with their unicode equivalent
	output := ""
	for i := 0; i < len(s); i++ {
		if s[i] == '\\' {
			i++
			switch s[i] {
				case '0': output += "\000"
				case 'b': output += "\b"
				case 't': output += "\t"
				case 'n': output += "\n"
				case 'f': output += "\f"
				case 'r': output += "\r"
				case '\047': output += "\047"
				case '\042': output += "\042"
				case '\\': output += "\\"
				default: panic("Encountered an unknown escape sequence, this should never happen")
			}
		} else {
			output += string(s[i])
		}
	}
	return output
}

func main() {
	//yyDebug = 20
  yyParse(NewLexer(os.Stdin))
	fmt.Println(top.Stmt.Repr())
}
